"""Download images

This script downloads a specific amount of images from the URLs
written in a csv file.

CSV file format: each row (except the first one) contains information
about an object. It must include the number of its category and the
URL of the main image. It may also include URLs of the additional
images.

In order to specify certain parameters, please refer to global
variables in this script:

The amount of images and categories
you need to download                          imgs_in_cat, cat_amount

The CSV file with object info                 input_file_name
The CSV file columns                          csv_col

The folder to download images to              img_folder
Folder with already downloaded images         backup_folder
"""

import csv
import os
import urllib.request
from urllib.error import HTTPError, URLError
from shutil import copyfile
from tqdm import tqdm


input_file_name = 'dump_with_category.csv'

img_folder = '1000x100/'
backup_folder = 'images/'

csv_col = {'cat': 1, 'img_urls': 2, 'main_img_url': 3}

imgs_in_cat = 100
cat_amount = 1000

backup_filename = 'categories_to_download.csv'


def csv_str_to_list(csv_string):
    """
    Convert a string from csv file to list.

            Parameters:
                    csv_string (str): A string of form
                            "['text', '42', ..., 'text']"

            Returns:
                    List of string, e.g.
                            ['text', '42', ..., 'text']
    """
    if len(csv_string) < 2:
        return []
    elif csv_string[0] == '[' and csv_string[-1] == ']':
        split = csv_string[1:-1].split(', ')
        return [word[1:-1] for word in split]
    else:
        return ['']


def download_img(img_url, img_name, img_folder, backup_folder=''):
    """
    Download a single image to the image folder. You choose its
    filename: it should be passed as  img_name  parameter. If a file
    with this filename already exists in img_folder nothing will happen.
    If a file with the filename exists in backup_folder it will be copied
    to the img_folder instead of downloading.

            Parameters:
                    img_url (str): Full image URL, e.g.
                    'http://www.gunnerkrigg.com//comics/00000001.jpg'

                    img_name (str): An intended image base name, e.g.
                    'comic_book.jpg'

                    img_folder (str): Folder to download images, e.g.
                    'img_folder/'
                    Please make sure it already exists before you
                    start downloading.

                    backup_folder (str): Another folder with
                    downloaded images to retrieve existing files
                    from there instead of downloading. E.g.
                    'backup_folder/'
    """
    if os.path.exists(img_folder + img_name):
        return

    if backup_folder and os.path.exists(backup_folder + img_name):
        copyfile(backup_folder + img_name,
                 img_folder + img_name)
        return

    urllib.request.urlretrieve(img_url,
                               img_folder + img_name)


def categories_to_download(imgs_in_cat, cat_amount,
                           input_file_name, backup_filename=''):
    """
    Return list of categories needed to be downloaded.

            Parameters:
                    imgs_in_cat (int): How many images are needed to
                    be downloaded in each category.

                    cat_amount (int): How many categories are needed
                    to be downloaded.

                    input_file_name (str): CSV file name with urls
                    (see the format at the top of this script).

                    backup_filename (str): Filename with data
                    generated by this function so it won't run again.

            Returns:
                    cats_to_download (list of str): list of
                    categories needed to be download in order to
                    satisfy requirements determined by the parameters
                     imgs_in_cat  and  cat_amount .
    """
    if os.path.exists(backup_filename):

        with open(backup_filename, 'r') as csvfile:
            reader = csv.reader(csvfile)
            cats_to_download = []
            for row in reader:
                cats_to_download.append(row[0])

        return cats_to_download

    # count total amount of images in each category
    num_of_imgs = dict()
    cats_ordered = []

    with open(input_path, 'r') as input_file:
        reader = csv.reader(input_file, quotechar='"',
                            quoting=csv.QUOTE_ALL,
                            skipinitialspace=True)

        line_number = -1
        for row in tqdm(reader):
            line_number += 1

            if line_number == 0 or len(row) < 4 or\
               row[csv_col['main_img_url']] == '':
                continue

            cat = row[csv_col['cat']]
            if cat not in num_of_imgs:
                num_of_imgs[cat] = 0
                cats_ordered.append(cat)

            imgs_amount = len(csv_str_to_list(row[csv_col['img_urls']])) + 1
            num_of_imgs[cat] += imgs_amount

    # determine which categories to download
    cats_to_download = []
    for cat in cats_ordered:
        if num_of_imgs[cat] >= imgs_in_cat:
            cats_to_download.append(cat)
        if len(cats_to_download) >= cat_amount:
            break

    if len(cats_to_download) < cat_amount:
        raise RuntimeError("Not sufficient amount of images for" +
                           "the parameters you've chosen.")

    with open(backup_filename, 'w') as csvfile:
        writer = csv.writer(csvfile)
        for cat in cats_to_download:
            writer.writerow([cat])

    return cats_to_download


def download(cats_to_download, input_file_name, csv_col,
             imgs_in_cat, img_folder, backup_folder=''):
    """
    Download images. For more detailed information regarding
    this function parameters please refer to the docstring of this
    script.

            Parameters:
                    cats_to_download (list of str): Categories
                    you need to download

                    input_file_name (str): CSV file name containing
                    objects info -- their categories and images

                    csv_col (dict): Describes the CSV file columns

                    imgs_in_cat (int): How many images in each
                    category needed to be downloaded

                    img_folder (str): Name of the folder to download
                    images to

                    backup_folder (str): Name of the folder where
                    images should be copied from in case they're
                    already there
    """
    imgs_downloaded = dict()
    for cat in cats_to_download:
        imgs_downloaded[cat] = 0

    exceptions = 0

    with open(input_file_name, 'r') as input_file:
        reader = csv.reader(input_file, quotechar='"',
                            quoting=csv.QUOTE_ALL,
                            skipinitialspace=True)

        line_number = -1
        for row in tqdm(reader):
            line_number += 1

            cat = row[csv_col['cat']]

            if cat not in cats_to_download or\
               imgs_downloaded[cat] >= imgs_in_cat:
                continue

            m_img_name = str(line_number) + '-M.jpg'
            m_img_url = row[csv_col['main_img_url']]

            img_urls = csv_str_to_list(row[csv_col['img_urls']])
            img_names = [str(line_number) + '-' + str(i+1) + '.jpg'
                         for i in range(len(img_urls))]

            try:

                download_img(m_img_url, m_img_name,
                             img_folder, backup_folder)

                imgs_downloaded[cat] += 1

                for i in range(len(img_urls)):
                    download_img(img_urls[i], img_names[i],
                                 img_folder, backup_folder)
                    imgs_downloaded[cat] += 1

            except (HTTPError, URLError, ValueError) as err:

                exceptions += 1
                print("Exceptions", exceptions)

            except KeyboardInterrupt:

                raise KeyboardInterrupt

            except:

                exceptions += 1
                print("Some new exception!", line_number)
                print("Exceptions", exceptions)


if __name__ == '__main__':

    print("### reading input file")
    cats_to_download = categories_to_download(
                            imgs_in_cat,
                            cat_amount,
                            input_file_name,
                            backup_filename
                       )

    print("### downloading")
    download(cats_to_download, input_file_name, csv_col,
             imgs_in_cat, img_folder)
