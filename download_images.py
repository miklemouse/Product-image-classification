"""Download images

This script downloads a specific amount of images from the URLs
written in a csv file.

CSV file format: each row (except the first one) contains information
about an object. It must include the number of its category and the
URL of the main image. It may also include URLs of the additional
images.
"""

import csv
import os
import urllib.request
from urllib.error import HTTPError, URLError
from shutil import copyfile
from tqdm import tqdm
import traceback
import getopt
import sys


def csv_str_to_list(csv_string):
    """
    Convert a string from csv file to list.

            Parameters:
                    csv_string (str): A string of form
                            "['text', '42', ..., 'text']"

            Returns:
                    List of string, e.g.
                            ['text', '42', ..., 'text']
    """
    if len(csv_string) < 2:
        return []
    elif csv_string[0] == '[' and csv_string[-1] == ']':
        split = csv_string[1:-1].split(', ')
        return [word[1:-1] for word in split]
    else:
        return ['']


def download_img(img_url, img_name, img_folder, backup_folder=''):
    """
    Download a single image to the image folder. You choose its
    filename: it should be passed as  img_name  parameter. If a file
    with this filename already exists in img_folder nothing will happen.
    If a file with the filename exists in backup_folder it will be copied
    to the img_folder instead of downloading.

            Parameters:
                    img_url (str): Full image URL, e.g.
                    'http://www.gunnerkrigg.com//comics/00000001.jpg'

                    img_name (str): An intended image base name, e.g.
                    'comic_book.jpg'

                    img_folder (str): Folder to download images, e.g.
                    'img_folder/'
                    Please make sure it already exists before you
                    start downloading.

                    backup_folder (str): Another folder with
                    downloaded images to retrieve existing files
                    from there instead of downloading. E.g.
                    'backup_folder/'
    """
    if os.path.exists(img_folder + img_name):
        return

    if backup_folder and os.path.exists(backup_folder + img_name):
        copyfile(backup_folder + img_name,
                 img_folder + img_name)
        return

    urllib.request.urlretrieve(img_url,
                               img_folder + img_name)


def categories_to_download(imgs_in_cat, cat_amount,
                           input_file_name, csv_col, download_type,
                           backup_filename=''):
    """
    Return list of categories needed to be downloaded.

            Parameters:
                    imgs_in_cat (int): How many images are needed to
                    be downloaded in each category.

                    cat_amount (int): How many categories are needed
                    to be downloaded.

                    input_file_name (str): CSV file name with urls
                    (see the format at the top of this script).

                    backup_filename (str): Filename with data
                    generated by this function so it won't run again.

            Returns:
                    cats_to_download (list of str): list of
                    categories needed to be download in order to
                    satisfy requirements determined by the parameters
                     imgs_in_cat  and  cat_amount .
    """
    if os.path.exists(backup_filename):

        with open(backup_filename, 'r') as csvfile:
            reader = csv.reader(csvfile)
            cats_to_download = []
            for row in reader:
                cats_to_download.append(row[0])

        return cats_to_download

    # count total amount of images in each category
    num_of_imgs = dict()
    cats_ordered = []

    with open(input_file_name, 'r') as input_file:
        reader = csv.reader(input_file, quotechar='"',
                            quoting=csv.QUOTE_ALL,
                            skipinitialspace=True)

        line_number = -1
        for row in tqdm(reader):
            line_number += 1

            if line_number == 0 or len(row) < 4 or\
               row[csv_col['main_img_url']] == '':
                continue

            cat = row[csv_col['cat']]
            if cat not in num_of_imgs:
                num_of_imgs[cat] = 0
                cats_ordered.append(cat)

            imgs_amount = 1
            if download_type == 'type':
                imgs_amount += len(
                                csv_str_to_list(row[csv_col['img_urls']])
                               )
            num_of_imgs[cat] += imgs_amount

    # determine which categories to download
    cats_to_download = []
    for cat in cats_ordered:
        if num_of_imgs[cat] >= imgs_in_cat:
            cats_to_download.append(cat)
        if len(cats_to_download) >= cat_amount:
            break

    if len(cats_to_download) < cat_amount:
        raise RuntimeError("Not sufficient amount of images for " +
                           "the parameters you've chosen.")

    if backup_filename:
        with open(backup_filename, 'w') as csvfile:
            writer = csv.writer(csvfile)
            for cat in cats_to_download:
                writer.writerow([cat])

    return cats_to_download


def download(cats_to_download, input_file_name, csv_col,
             imgs_in_cat, img_folder, download_type, backup_folder=''):
    """
    Download images. For detailed information regarding the parameters
    of this function please refer to the docstring of this script.

            Parameters:
                    cats_to_download (list of str): Categories
                    you need to download

                    input_file_name (str): CSV file name containing
                    objects info -- their categories and images

                    csv_col (dict): Describes the CSV file columns

                    imgs_in_cat (int): How many images in each
                    category needed to be downloaded

                    img_folder (str): Name of the folder to download
                    images to

                    backup_folder (str): Name of the folder where
                    images should be copied from in case they're
                    already there
    """
    imgs_downloaded = dict()
    for cat in cats_to_download:
        imgs_downloaded[cat] = 0

    exceptions = 0

    if not os.path.exists(img_folder):
        os.mkdir(img_folder)

    with open(input_file_name, 'r') as input_file:
        reader = csv.reader(input_file, quotechar='"',
                            quoting=csv.QUOTE_ALL,
                            skipinitialspace=True)

        line_number = -1
        for row in tqdm(reader):
            line_number += 1

            if line_number == 0 or len(row) < 4 or\
               not row[csv_col['main_img_url']]:
                continue

            cat = row[csv_col['cat']]
            if cat not in cats_to_download or\
               imgs_downloaded[cat] >= imgs_in_cat:
                continue

            m_img_name = str(line_number) + '-M.jpg'
            m_img_url = csv_str_to_list(
                            row[csv_col['main_img_url']]
                        ).pop()

            img_urls = csv_str_to_list(row[csv_col['img_urls']])
            img_names = [str(line_number) + '-' + str(i+1) + '.jpg'
                         for i in range(len(img_urls))]

            try:

                download_img(m_img_url, m_img_name,
                             img_folder, backup_folder)

                imgs_downloaded[cat] += 1

                if download_type == 'type':
                    for i in range(len(img_urls)):
                        download_img(img_urls[i], img_names[i],
                                     img_folder, backup_folder)
                        imgs_downloaded[cat] += 1

            except (HTTPError, URLError, ValueError) as err:

                exceptions += 1
                print("Html exception. Exceptions:", exceptions)

            except KeyboardInterrupt:

                raise KeyboardInterrupt

            except:

                exceptions += 1
                print("Some new exception!", line_number)
                traceback.print_exc()
                print("Exceptions:", exceptions)


def main(argv):

    input_file_name = ''

    img_folder = ''

    imgs_in_cat = -1
    cat_amount = -1

    download_type = ''

    csv_col = {'cat': 1, 'img_urls': 2, 'main_img_url': 3}

    backup_folder = ''
    backup_filename = ''

    try:
        opts, _ = getopt.getopt(argv, "hi:o:n:m:t:b:f:",
                                ["inp_file=",
                                 "output_folder=",
                                 "imgs_in_cat=",
                                 "cat_amount=",
                                 "type=",
                                 "backup_folder=",
                                 "backup_filename="])

    except getopt.GetoptError:
        print ('download_images.py -h for help')
        sys.exit(2)

    for opt, arg in opts:
        if opt == '-h':
            print ('download_images.py -i <inp_file> ' +
                   '-o <output_folder> -n <imgs_in_cat> ' +
                   '-m <cat_amount> -t <type> -b [backup_folder]' +
                   ' -f [backup_filename]')
            print('The CSV file with object info <inp_file>')
            print('The folder to download images to <output_folder>')
            print('The amount of images and categories you need to ' +
                  'download imgs_in_cat, cat_amount')
            print('<type>: either "cat" or "type"')
            print('Folder with already downloaded images [backup_folder]')
            print('CSV file with list of categories to download' +
                  '[backup_filename]')

            sys.exit()
        if opt in ["-i", "--inp_file"]:
            input_file_name = arg
        elif opt in ["-o", "--output_folder"]:
            img_folder = arg
        elif opt in ["-n", "--imgs_in_cat"]:
            imgs_in_cat = int(arg)
        elif opt in ["-m", "--cat_amount"]:
            cat_amount = int(arg)
        elif opt in ["-t", "--type"]:
            download_type = opt
        elif opt in ["-b", "--backup_folder"]:
            backup_folder = arg
        elif opt in ["-f", "--backup_filename"]:
            backup_filename = arg

    if not input_file_name or not img_folder or\
       not download_type or imgs_in_cat == -1 or cat_amount == -1:
        print ('download_images.py -h for help')
        sys.exit(2)

    if img_folder[-1] != '/':
        img_folder += '/'

    if backup_folder and backup_folder[-1] != '/':
        backup_folder += '/'

    # Read input file and determine which categories to download
    print("Reading input file...")
    cats_to_download = categories_to_download(
                            imgs_in_cat,
                            cat_amount,
                            input_file_name,
                            csv_col,
                            download_type,
                            backup_filename
                       )

    # Download the images
    print("Downloading...")
    download(cats_to_download, input_file_name, csv_col,
             imgs_in_cat, img_folder, download_type, backup_folder)


if __name__ == '__main__':
    main(sys.argv[1:])
